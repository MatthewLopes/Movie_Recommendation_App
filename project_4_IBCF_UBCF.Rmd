---
title: "project_4_IBCF_UBCF"
output: html_document
date: "2022-12-04"
---

```{r}
library(dplyr)
library(Matrix)
library(recommenderlab)
```

```{r}
myurl = "https://liangfgithub.github.io/MovieData/"
ratings = read.csv(paste0(myurl, 'ratings.dat?raw=true'), 
                   sep = ':',
                   colClasses = c('integer', 'NULL'), 
                   header = FALSE)
colnames(ratings) = c('UserID', 'MovieID', 'Rating', 'Timestamp')
movies = readLines(paste0(myurl, 'movies.dat?raw=true'))
movies = strsplit(movies, split = "::", fixed = TRUE, useBytes = TRUE)
movies = matrix(unlist(movies), ncol = 3, byrow = TRUE)
movies = data.frame(movies, stringsAsFactors = FALSE)
colnames(movies) = c('MovieID', 'Title', 'Genres')
movies$MovieID = as.integer(movies$MovieID)
movies$Title = iconv(movies$Title, "latin1", "UTF-8")
# Create columns with split genres
movies = movies %>% separate(Genres, c("genre_1", "genre_2", "genre_3", "genre_4", "genre_5", "genre_6"), sep = "\\|")
small_image_url = "https://liangfgithub.github.io/MovieImages/"
movies$image_url = sapply(movies$MovieID, 
                          function(x) paste0(small_image_url, x, '.jpg?raw=true'))
i = paste0('u', ratings$UserID)
j = paste0('m', ratings$MovieID)
x = ratings$Rating
tmp = data.frame(i, j, x, stringsAsFactors = T)
Rmat = sparseMatrix(as.integer(tmp$i), as.integer(tmp$j), x = tmp$x)
rownames(Rmat) = levels(tmp$i)
colnames(Rmat) = levels(tmp$j)
Rmat = new('realRatingMatrix', data = Rmat)


train = Rmat[1:500, ]
test = Rmat[501, ]
```

## Scenario 1
```{r}
# My favorite genre.You can select any genre that is listed in movies. But for testing purposes I used Action
genre = "Action"

# Filter dataset on genre in any of the genre columns
movies_with_selected_genre = movies %>% filter(genre_1 == genre | genre_2 == genre | genre_3 == genre | genre_4 == genre | genre_5 == genre | genre_6 == genre)

# Join our movies that pertain to the selected genre to our ratings dataset
joined_data = inner_join(movies_with_selected_genre, ratings, by="MovieID")
```

### Recommendation Scheme 1
#### Recommend movies based on highest average rating in the given genre with more than 1000 total ratings
```{r}
# Get all the mean reviews for each movies as well as total reviews
grouped_data = joined_data %>%
  group_by(MovieID, Title, image_url) %>%
  dplyr::summarize(Ratings_Mean = mean(Rating, na.rm=TRUE), Count_of_Reviews = sum(Rating, na.rm=TRUE))

# Order movies with highest average ratings
ordered_by_rating <- grouped_data[with(grouped_data,order(-Ratings_Mean)),]
# Remove movies with less than 1000 total ratings
ordered_by_rating <- ordered_by_rating %>% filter(Count_of_Reviews > 1000)
# Select movies with top 10 average ratings
top_10 <- ordered_by_rating[1:10,]
  
# Display recommended movies
top_10 %>%
  mutate(Image = paste0('<img src="', 
                        small_image_url, 
                        MovieID, 
                        '.jpg?raw=true"></img>')) %>%
  select('Image', 'Title') %>%
  datatable(class = "nowrap hover row-border", 
            escape = FALSE, 
            options = list(dom = 't',
                          scrollX = TRUE, autoWidth = TRUE))
```

### Recommendation Scheme 2
#### Recommend movies based on most number of ratings in the given genre
```{r}
# Get all the mean reviews for each movies as well as total reviews
grouped_data = joined_data %>%
  group_by(MovieID, Title, image_url) %>%
  dplyr::summarize(Ratings_Mean = mean(Rating, na.rm=TRUE), Count_of_Reviews = sum(Rating, na.rm=TRUE))

# Order movies by number of reviews
ordered_by_popularity <- grouped_data[with(grouped_data,order(-Count_of_Reviews)),]
# Select movies with highest number of reviews
top_10 <- ordered_by_popularity[1:10,]

# Display recommended movies
top_10 %>%
  mutate(Image = paste0('<img src="', 
                        small_image_url, 
                        MovieID, 
                        '.jpg?raw=true"></img>')) %>%
  select('Image', 'Title') %>%
  datatable(class = "nowrap hover row-border", 
            escape = FALSE, 
            options = list(dom = 't',
                          scrollX = TRUE, autoWidth = TRUE))
```


## UBCF
```{r}
data = as(train, "matrix")
user.means = rowMeans(data, na.rm = TRUE)
data = data - user.means
newdata = as(Rmat[501, ], "matrix")
newuser.mean = mean(newdata, na.rm = TRUE)
newdata = newdata - newuser.mean
```

```{r}
sim1 = proxy::simil(data, newdata, method = "cosine")
sim1 = (1 + sim1)/2

k = 20

top_k_ind = order(sim1, decreasing = TRUE)[1:k]
top_k_train_user = data[top_k_ind,]
sorted_sim1 = sim1[top_k_ind]

```

```{r}

# Our mypred

row_products = top_k_train_user * sorted_sim1

mypred_numerator = colSums(row_products, na.rm=TRUE)

mypred_denominator = colSums(1 * (!is.na(top_k_train_user)) * sorted_sim1, na.rm=TRUE)

mypred = mypred_numerator / mypred_denominator

mypred = mypred + newuser.mean

mypred[sapply(mypred, is.infinite)] <- NA

mypred[sapply(mypred, is.nan)] <- NA

user_rated_movie_indices = which(!is.na(newdata))

mypred[user_rated_movie_indices] = NA
```


```{r}

#recommender UBCF

recommender.UBCF <- Recommender(train, method = "UBCF",
                                parameter = list(normalize = 'center', 
                                                 method = 'Cosine', 
                                                 nn = 20))

p.UBCF <- predict(recommender.UBCF, test, type="ratings")
p.UBCF <- as.numeric(as(p.UBCF, "matrix"))

sum(is.na(p.UBCF) != is.na(mypred)) ### should be zero
max(abs(p.UBCF - mypred), na.rm = TRUE)  ### should be less than 1e-06

```


```{r}

#IBCF

data = as(train, "matrix")
user.means = rowMeans(data, na.rm = TRUE)
data = data - user.means
newdata = as(Rmat[501, ], "matrix")
newuser.mean = mean(newdata, na.rm = TRUE)
newdata = newdata - newuser.mean

sim_mat = proxy::simil(t(data), method = "cosine")
sim_mat = as.matrix(sim_mat)
sim_mat = (1 + sim_mat)/2  
n = dim(sim_mat)[1]

sim_top30 = matrix(NA, n, n) 
colnames(sim_top30) = colnames(sim_mat)

for(i in 1:n){
  neighbor_ids = tail(order(sim_mat[i,], decreasing = FALSE, na.last=FALSE), 30)
  sim_top30[i, neighbor_ids] = sim_mat[i, neighbor_ids]
}

# Numerator and Denominator

newdata.notNA = !is.na(newdata) # where the newdata is not NA

ibcf_num_mtx = matrix(NA, n, n) 

for(i in 1:n){ 
  ibcf_num_mtx[i,] = newdata * sim_top30[i,] 
}

ibcf_numerator = rowSums(ibcf_num_mtx, na.rm = TRUE)

ibcf_denom_mtx = t(t(sim_top30) * drop(newdata.notNA))

ibcf_denominator = rowSums(ibcf_denom_mtx, na.rm=TRUE)

mypred_ibcf = ibcf_numerator / ibcf_denominator

mypred_ibcf[sapply(mypred_ibcf, is.nan)] <- NA

mypred_ibcf[sapply(mypred_ibcf, is.infinite)] <- NA

#prof said we can do cleaning at the end
inds = which(!is.na(newdata))

mypred_ibcf[inds] = NA

mypred_ibcf = mypred_ibcf + newuser.mean

```

```{r}
recommender.IBCF <- Recommender(train, method = "IBCF",
                                parameter = list(normalize = 'center', 
                                                 method = 'Cosine', 
                                                 k = 30))

p.IBCF <- predict(recommender.IBCF, test, type="ratings")
p.IBCF <- as.numeric(as(p.IBCF, "matrix"))

## first output: should be less than 10
sum(is.na(p.IBCF) != is.na(mypred_ibcf))  

## second output: should be less than 10%
mydiff = abs(p.IBCF - mypred_ibcf)
sum(mydiff[!is.na(mydiff)] > 1e-6) / sum(!is.na(mydiff)) 
```


